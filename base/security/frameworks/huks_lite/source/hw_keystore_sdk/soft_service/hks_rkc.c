#include "hks_rkc.h"
#include <mbedtls/pkcs5.h>
#include "securec.h"
#include "common/hks_common.h"
#include "common/hks_log_utils.h"
#include "common/hks_mem.h"
#include "hks_errno.h"
#include "hks_file.h"
#ifdef _SECURE_ENVIREMENT_NMI_
#include <hi_cipher.h>
#include <hi_efuse.h>
#include "hks_service.h"
#endif
#if defined(_HILINK_PRODUCT_)
#else
#endif
#define IV_SHA256_RESULT_LEN 32
#define KDF_ITERATION_TIMES 1000 /* the lowest iteration times, cannot change smaller */
static int32_t hks_rkc_create_ksf(void)
{
    struct hks_rkc_ksf_data *new_ksf_data =
        (struct hks_rkc_ksf_data *)HKS_MALLOC(HKS_RKC_KSF_DATA_SIZE);

    if (new_ksf_data == NULL) {
        log_error("malloc ksf data fail");
        return HKS_ERROR_MALLOC_FAIL;
    }

    /* The root key component data must be clear firstly. */
    (void)memset_s(new_ksf_data, HKS_RKC_KSF_DATA_SIZE, 0,
        HKS_RKC_KSF_DATA_SIZE);

    int32_t rc;

    do {
        /* Fill some fixed field. */
        new_ksf_data->version = g_hks_rkc_cfg.version;
        new_ksf_data->rmk_iter = g_hks_rkc_cfg.rmk_iter;
        new_ksf_data->rmk_hash_alg = g_hks_rkc_cfg.rmk_hash_alg;

        /* Two material are generated by random number. */
        rc = hks_rkc_make_random_material(new_ksf_data);
        if (rc != HKS_STATUS_OK) {
            log_error("generate material fail,rc=%d", rc);
            break;
        }

        /* The salt value is generated by random number. */
        rc = hks_gen_random(new_ksf_data->rmk_salt, HKS_RKC_SALT_LEN);
        if (rc != HKS_STATUS_OK) {
            log_error("generate rmk_salt fail,rc=%d", rc);
            break;
        }

        /* make master key. */
        rc = hks_rkc_make_mk(new_ksf_data);
        if (rc != HKS_STATUS_OK) {
            log_error("make mk fail,rc=%d", rc);
            break;
        }

        /* Write the root key component data into all keystore files */
        rc = hks_rkc_write_all_ksf(new_ksf_data);
        if (rc != HKS_STATUS_OK)
            break;

        log_info("create root key component success");
    } while (0);

    /* the data of root key should be cleared after use */
    (void)memset_s(new_ksf_data, HKS_RKC_KSF_DATA_SIZE, 0,
        HKS_RKC_KSF_DATA_SIZE);
    hks_free_ptr(new_ksf_data);

    return rc;
}
static int32_t hks_rkc_recover_mk_mem(struct hks_rkc_ksf_data *ksf_data)
{
    int32_t rc = memcpy_s(&(g_hks_rkc_mk.mk_created_time),
        sizeof(g_hks_rkc_mk.mk_created_time),
        &(ksf_data->mk_created_time),
        sizeof(ksf_data->mk_created_time));

    if (rc != HKS_STATUS_OK)
        return HKS_ERROR_INTERNAL_UNKOWN;

    rc = memcpy_s(&(g_hks_rkc_mk.mk_expired_time),
        sizeof(g_hks_rkc_mk.mk_expired_time),
        &(ksf_data->mk_expired_time),
        sizeof(ksf_data->mk_expired_time));
    if (rc != HKS_STATUS_OK)
        return HKS_ERROR_INTERNAL_UNKOWN;

    struct hks_blob mk;

    rc = hks_blob_init(&mk, sizeof(uint8_t), HKS_RKC_MK_LEN,
        HKS_BLOB_TYPE_KEY);
    if (rc != HKS_STATUS_OK) {
        log_error("init mk fail");
        return HKS_ERROR_MALLOC_FAIL;
    }

    do {
        /* generate the mask of master key */
        rc = hks_gen_random(g_hks_rkc_cfg.mk_mask, HKS_RKC_MK_LEN);
        if (rc != HKS_STATUS_OK)
            break;

        struct hks_blob ciphertext = { HKS_BLOB_TYPE_KEY, ksf_data->mk_ciphertext, HKS_RKC_MK_CIPHERTEXT_LEN };

        rc = hks_rkc_mk_crypt(ksf_data, &mk, &ciphertext,
            HKS_RKC_DECRYPT);
        if (rc != HKS_STATUS_OK) {
            rc = HKS_ERROR_INVALID_KEY_FILE;
            break;
        }

        /* the master key in memory should be masked */
        hks_rkc_mask_mk(&mk);
    } while (0);

    hks_blob_destroy(&mk);

    return rc;
}
static int32_t hks_rkc_recover_rk_mem(const struct hks_rkc_ksf_data *ksf_data)
{
    int32_t rc = memcpy_s(&(g_hks_rkc_cfg.rk_created_time),
        sizeof(g_hks_rkc_cfg.rk_created_time),
        &(ksf_data->rk_created_time),
        sizeof(ksf_data->rk_created_time));

    if (rc != HKS_STATUS_OK)
        return HKS_ERROR_INTERNAL_UNKOWN;

    rc = memcpy_s(&(g_hks_rkc_cfg.rk_expired_time),
        sizeof(g_hks_rkc_cfg.rk_expired_time),
        &(ksf_data->rk_expired_time),
        sizeof(ksf_data->rk_expired_time));
    if (rc != HKS_STATUS_OK)
        return HKS_ERROR_INTERNAL_UNKOWN;

    return HKS_STATUS_OK;
}
#ifdef _SECURE_ENVIREMENT_NMI_
#endif
void hks_rkc_destroy(void)
{
    g_hks_rkc_cfg.state = HKS_RKC_STATE_ON_DEL;

    uint32_t i = 0;

    for (; i < HKS_RKC_KSF_NUM; ++i)
        hks_file_del_s(g_hks_rkc_cfg.ksf_attr.name[i]);

    hks_rkc_clear_mem();
}
void hks_rkc_clear_mem(void)
{
    uint32_t i = 0;

    for (; i < HKS_RKC_KSF_NUM; ++i)
        hks_free_ptr(g_hks_rkc_cfg.ksf_attr.name[i]);

    hks_free_ptr(g_hks_rkc_cfg.entropy);

    (void)memset_s(&g_hks_rkc_cfg, sizeof(g_hks_rkc_cfg), 0,
        sizeof(g_hks_rkc_cfg));

    (void)memset_s(&g_hks_rkc_mk, sizeof(g_hks_rkc_mk), 0,
        sizeof(g_hks_rkc_mk));
}
#ifdef _SECURE_ENVIREMENT_NMI_
#endif
#ifndef _SECURE_ENVIREMENT_NMI_
#endif
#ifdef _SECURE_ENVIREMENT_NMI_
#else
#endif
